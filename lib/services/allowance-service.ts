/**
 * Letter allowance and eligibility checking service
 * Extracts complex business logic for cleaner API routes
 */

import { createClient } from '@/lib/supabase/server'
import type { LetterAllowance } from '@/lib/types/letter.types'

/**
 * Result of checking if a user can generate a letter
 */
export interface GenerationEligibility {
  canGenerate: boolean
  isFreeTrial: boolean
  hasAllowance: boolean
  remainingAllowance: number | null
  totalGenerated: number
  reason?: string
}

/**
 * Check letter allowance from database
 */
export async function checkLetterAllowance(userId: string): Promise<LetterAllowance> {
  const supabase = await createClient()

  const { data } = await supabase.rpc('check_letter_allowance', {
    u_id: userId,
  })

  return {
    has_allowance: data?.has_access ?? false,
    remaining: data?.letters_remaining ?? 0,
  }
}

/**
 * Get total letters generated by user
 */
export async function getTotalLettersGenerated(userId: string): Promise<number> {
  const supabase = await createClient()

  const { data } = await supabase
    .from('profiles')
    .select('total_letters_generated')
    .eq('id', userId)
    .single()

  return data?.total_letters_generated || 0
}

/**
 * Check if user is eligible for free trial (first letter)
 */
export function isFreeTrialEligible(
  totalGenerated: number,
  hasAllowance: boolean
): boolean {
  return totalGenerated === 0 && !hasAllowance
}

/**
 * Result of atomic check and deduct operation
 */
export interface AtomicDeductionResult {
  success: boolean
  remaining: number | null
  errorMessage: string | null
  isFreeTrial: boolean
  isSuperAdmin: boolean
}

/**
 * Atomically check eligibility AND deduct letter allowance in a single operation.
 * This prevents race conditions where concurrent requests could pass the check
 * and all deduct, resulting in over-generation.
 *
 * Uses the database-level SELECT FOR UPDATE lock to ensure atomicity.
 */
export async function checkAndDeductAllowance(userId: string): Promise<AtomicDeductionResult> {
  const supabase = await createClient()

  const { data, error } = await supabase.rpc('check_and_deduct_allowance', {
    u_id: userId,
  })

  if (error) {
    console.error('[Allowance] check_and_deduct_allowance RPC failed:', error)
    return {
      success: false,
      remaining: null,
      errorMessage: error.message,
      isFreeTrial: false,
      isSuperAdmin: false,
    }
  }

  // The RPC returns a single row with the results
  if (!data || data.length === 0) {
    return {
      success: false,
      remaining: null,
      errorMessage: 'Failed to check allowance',
      isFreeTrial: false,
      isSuperAdmin: false,
    }
  }

  const result = Array.isArray(data) ? data[0] : data

  return {
    success: result.success as boolean,
    remaining: result.remaining as number | null,
    errorMessage: result.error_message as string | null,
    isFreeTrial: result.is_free_trial as boolean,
    isSuperAdmin: result.is_super_admin as boolean,
  }
}

/**
 * Comprehensive check for letter generation eligibility
 * Combines free trial and allowance checks
 *
 * @deprecated Use checkAndDeductAllowance() for atomic operations instead.
 * This is kept for backward compatibility but should not be used for
 * allowance deduction as it has race conditions.
 */
export async function checkGenerationEligibility(
  userId: string
): Promise<GenerationEligibility> {
  // Run checks in parallel for performance
  const [totalGenerated, allowance] = await Promise.all([
    getTotalLettersGenerated(userId),
    checkLetterAllowance(userId),
  ])

  const hasAllowance = allowance.has_allowance
  const remainingAllowance = allowance.remaining

  // Determine if free trial applies
  const isFreeTrial = isFreeTrialEligible(totalGenerated, hasAllowance)

  // Check if user can generate
  const canGenerate = isFreeTrial || hasAllowance

  // Provide reason if not eligible
  let reason: string | undefined
  if (!canGenerate) {
    if (totalGenerated === 0) {
      reason = 'No letter allowance available. Please upgrade your plan.'
    } else {
      reason = 'No letter credits remaining. Please upgrade your plan.'
    }
  }

  return {
    canGenerate,
    isFreeTrial,
    hasAllowance,
    remainingAllowance,
    totalGenerated,
    reason,
  }
}

/**
 * @deprecated Use checkAndDeductAllowance() instead.
 * This separate check-then-deduct pattern has a race condition.
 */
export async function deductLetterAllowance(userId: string): Promise<{
  success: boolean
  wasDeducted: boolean
  error?: string
}> {
  const supabase = await createClient()

  const { data, error } = await supabase.rpc('deduct_letter_allowance', {
    u_id: userId,
  })

  if (error) {
    return {
      success: false,
      wasDeducted: false,
      error: error.message,
    }
  }

  return {
    success: true,
    wasDeducted: data ?? false,
    error: !data ? 'No letter allowances remaining (or race condition prevented overage)' : undefined,
  }
}

/**
 * Refund letter allowance (e.g., after failed generation)
 * Uses atomic database operation
 */
export async function refundLetterAllowance(
  userId: string,
  amount: number = 1
): Promise<{ success: boolean; error?: string }> {
  const supabase = await createClient()

  const { data, error } = await supabase.rpc('refund_letter_allowance', {
    u_id: userId,
    amount,
  })

  if (error) {
    console.error('[Allowance] refund_letter_allowance RPC failed:', error)
    return {
      success: false,
      error: error.message,
    }
  }

  // The RPC returns a table with success and error_message
  const result = Array.isArray(data) ? data[0] : data

  if (!result || !result.success) {
    return {
      success: false,
      error: result?.error_message || 'Refund failed',
    }
  }

  return { success: true }
}

/**
 * Increment total letters generated counter
 */
export async function incrementTotalLetters(userId: string): Promise<{ success: boolean; error?: string }> {
  const supabase = await createClient()

  const { error } = await supabase.rpc('increment_total_letters', {
    p_user_id: userId,
  })

  if (error) {
    return {
      success: false,
      error: error.message,
    }
  }

  return { success: true }
}

/**
 * Check if deduction should be skipped based on user type
 */
export function shouldSkipDeduction(eligibility: GenerationEligibility): boolean {
  return eligibility.isFreeTrial
}

/**
 * Eligibility check result for API responses
 */
export interface EligibilityCheckResult {
  eligible: boolean
  needsSubscription: boolean
  error?: string
}

/**
 * Quick API-friendly eligibility check
 */
export async function checkApiEligibility(userId: string): Promise<EligibilityCheckResult> {
  const eligibility = await checkGenerationEligibility(userId)

  if (!eligibility.canGenerate) {
    return {
      eligible: false,
      needsSubscription: true,
      error: eligibility.reason || 'No letter credits remaining',
    }
  }

  return {
    eligible: true,
    needsSubscription: false,
  }
}
